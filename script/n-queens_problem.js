

const n = 8;
const width = 62.5*n;;
const height = 62.5*n;
const xblock = width/n;
const yblock = height/n;

var board;
var queenYCoordinates;
var heuristicTable;
var totalHeuristicCost;
var queenStart;


function setup() {
    createCanvas(width, height);

    board = []
    queenYCoordinates = []
    heuristicTable = []
    totalHeuristicCost = Math.pow(10, 1000);
    queenStart = [4, 5, 6, 3, 4, 5, 6, 5]


    // Coloring the board
    colorize();

    // Randomly putting one queen in each column with a total of n queens
    setQueensRandom();
    drawQueens();

    /*
    The successor of a state are all possible states generated by moving a single queen to another square in the same column.
    This means that each state has 8*7 = 56 successors.
    Making the heuristic cost table for each possible successor obtained by moving a queen within its column.
    The heuristic cost function h is the number of pairs of queens that are attacking each other, either directly or indirectly.
    */

    // "Initialize" the heuristic table
    setHeuristicTable();

    undrawQueens();

    // Start search-loop
    var count = 0;
    while (totalHeuristicCost > 0) {
        if (count > 1000) {
            break
        }
        search();
        count++;
        
    }
    
    drawQueens();



   // drawQueens();
    

}

function undrawQueens(){
    for (var y = 0; y < n; y ++) {
        for (var x = 0; x < n; x ++) {
            if ((y + x + 1) % 2 == 0) {
                fill(255, 255, 255); // white
            } else {
                fill(0, 0, 0); // black
            }
            rect(y * xblock, x * yblock, (y + 1) * xblock, (x + 1) * yblock);     
        } 
    }
}


function colorize(){
    for (var y = 0; y < n; y ++) {
        board[y] = []
        for (var x = 0; x < n; x ++) {
            if ((y + x + 1) % 2 == 0) {
                fill(255, 255, 255); // white
            } else {
                fill(0, 0, 0); // black
            }
            rect(y * xblock, x * yblock, (y + 1) * xblock, (x + 1) * yblock);     
        } 
    }
}



function setQueensRandom() {
    for (var x = 0; x < n; x ++) {
        //var queen_y = Math.floor(Math.random() * 8)
        var queen_y = queenStart[x]
        
        for (var y = 0; y < n; y ++) {
            if (y === queen_y){
                board[y][x] = true
                queenYCoordinates[x] = queen_y
            }
            else {
                board[y][x] = false
            }
        }
    }
}

function drawQueens(){
    for (var x = 0; x < n; x ++) {
        for (var y = 0; y < n; y ++) {
            if (board[y][x]){
                fill('orange')
                ellipse(x*xblock+30, y*yblock+30 , xblock/1.5, yblock/1.5)
            }
        }
    }
}

function setHeuristicTable() {
    for (x = 0; x < n; x++) {
        heuristicTable[x] = []
        for (y = 0; y < n; y++) {
            heuristicTable[x].push(0)
        }
    }
}

function getHeuristicCost() {
    var totalConflictsCount = 0
    var totalConflicts = {}

    for (var x = 0; x < n; x ++) {
        for (var y = 0; y < n; y ++) {
            if (board[y][x]) {
                var this_square = [y, x]
                var result = getConflictCount(y, x)
                var count = result[0]
                var conflicts = result[1]
                /*
                console.log("I square x = " + x + ", y = " + y);
                console.log("Found " + count + " conflicts");
                console.log(conflicts);
                console.log("-----------------------------------");

                Add conflict pairs to the totalConflict-set if the pair is not already there
                The set is made up by key-value pairs where the key is a square,
                and the value is a list of all its conflicting squares to the right
                */

                totalConflicts[this_square] = []
                for (var i = 0; i < conflicts.length; i++) {
                    var conflict_square = conflicts[i]
                    totalConflicts[this_square].push(conflict_square)
                    totalConflictsCount ++;
                }
            }
        }
    }

    return totalConflictsCount
}



function draw() {
}


function search() {

    for (x = 0; x < n; x++) {
        var queenCoord = queenYCoordinates[x]
        
        board[queenCoord][x] = false
        for (y = 0; y < n; y++) {
            board[y][x] = true
            heuristicTable[y][x] = getHeuristicCost()
            board[y][x] = false
        }
        board[queenCoord][x] = true
    }

    var globalMin = [-1, -1, Math.pow(10, 1000)];
    var globalMins = []

    for (x = 0; x < n; x++) {
        var columnHeuristics = []
        for (y = 0; y < n; y++) {
            columnHeuristics.push(heuristicTable[y][x])
        }
        var columnMin = Math.min.apply(Math, columnHeuristics)
        var columnMinIndex = columnHeuristics.indexOf(columnMin)

        if (columnMin < globalMin[2]) {
            globalMin = [columnMinIndex, x, columnMin]
            globalMins = [globalMin]
        }
        else if (columnMin === globalMin[2]) {
            globalMins.push([columnMinIndex, x, columnMin])
        }
    }
    
    console.log(globalMins);
    
    // Move the queen 
    var globalMinY = globalMin[0]
    var globalMinX = globalMin[1]
    var newTotalHeuristicCost = globalMin[2]
    var currentQueenY = queenYCoordinates[globalMinX]
    console.log(globalMinY, globalMinX, newTotalHeuristicCost);
    

    queenYCoordinates[globalMinX] = globalMinY

    board[currentQueenY][globalMinX] = false
    board[globalMinY][globalMinX] = true
    totalHeuristicCost = newTotalHeuristicCost
    
    //console.log(globalMin);
    //console.log(heuristicTable);

}


function getConflictCount(current_y, current_x) {
    conflictSquares = []
    count = 0;

    // Only checks square to the right 

    // Sideways to the right
    var x = current_x + 1
    var y = current_y
    while (x < n) {
        if (board[y][x]){
            conflictSquares.push([y, x])
            count++;
        }
        x++;
    }

    // Diagonally upwards right
    var y = current_y - 1
    var x = current_x + 1 
    while (y >= 0 && x < n) {
        if (board[y][x]){
            conflictSquares.push([y, x]);
            count++;
        }
        y--;
        x++;
    }

    // Diagonally downwards right
    var y = current_y + 1
    var x = current_x + 1 
    while (y < n && x < n) {
        if (board[y][x]){
            conflictSquares.push([y, x]);
            count++;
        }
        y++;
        x++;
    }


    var result = []
    result.push(count)
    result.push(conflictSquares)
    return result;

}